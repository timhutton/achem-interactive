<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script>

function p2( x, y ) { return { x:x, y:y }; }
function add( a, b ) { return p2( a.x + b.x, a.y + b.y ); }
function sub( a, b ) { return p2( a.x - b.x, a.y - b.y ); }
function mul( a, f ) { return p2( a.x * f, a.y * f ); }
function dot( a, b ) { return a.x * b.x + a.y * b.y; }
function len2( a ) { return dot(a,a); }
function dist( a, b ) { return Math.sqrt( len2( sub( a, b ) ) ); }
function assign( a, b ) { a.x = b.x; a.y = b.y; }
function normalize( a ) { return mul( a, 1 / Math.sqrt( len2( a ) ) ); }
function mid( a, b ) { return mul( add( a, b ), 0.5 ); }

function atom(pos, type, state) {
    return { p:pos, type: type, state: state };
}

var target_bond_length = 1;
var radius = target_bond_length / 3.0;
var scale = 60;
var offset = p2(200, 200);
var atoms = [];
var bonds = [];


function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function onMouseMove( evt ) {
    var pos = getMousePos( canvas, evt );
}

function onMouseDown( evt ) {
    var pos = getMousePos( canvas, evt );
}

function onMouseUp( evt ) {
    redraw();
}

function pointInRect( p, rect ) {
    return p.x > rect.x && p.x < ( rect.x + rect.width ) &&
           p.y > rect.y && p.y < ( rect.y + rect.height );
}

// too close = repulsion, too far = attraction
function get_connection_force_on_a( a, b ) {
    var x = sub( a, b );
    var ab2 = len2( x );
    var ab = Math.sqrt( ab2 );
    var k = 0.15;
    var d = target_bond_length;
    var ret = mul( x, k * ( d - ab ) / ab );
    return ret;
}

function get_collision_force_on_a( a, b ) {
    var x = sub( a, b );
    var ab2 = len2( x );
    var ab = Math.sqrt( ab2 );
    var k = 0.1;
    var d = radius * 2.6;
    if( ab > d ) { return p2(0,0); } // no force if atoms aren't overlapping
    var ret = mul( x, k * ( d - ab ) / ab );
    return ret;
}

// move the verts a little in the direction of sum of the forces acting on them
function relax() {
    var forces = [];
    for(var i = 0; i < atoms.length; i++) {
        forces.push( p2(0,0) );
    }
    // add a spring force along edges
    bonds.forEach( (iA, iB) => {
        var a = atoms[iA];
        var b = atoms[iB];
        // add the spring forces from this edge
        var m = get_connection_force_on_a( a.p, b.p );
        forces[iA] = add( forces[iA], m );
        forces[iB] = sub( forces[iB], m );
    });
    // add a collision force where atoms are overlapping
    for(var iA = 0; iA < atoms.length; iA++) {
        for(var iB = iA + 1; iB < atoms.length; iB++) {
            var a = atoms[iA];
            var b = atoms[iB];
            var m = get_collision_force_on_a( a.p, b.p );
            forces[iA] = add( forces[iA], m );
            forces[iB] = sub( forces[iB], m );
        }
    }
    // apply the movement
    for(var i = 0; i < atoms.length; i++) {
        atoms[i].p = add( atoms[i].p, forces[i] );
    }
}

function addAtom( pos, type, state ) {
    atoms.push( atom( pos, type, state ) );
    return atoms.length - 1;
}

function addBond( iA, iB ) {
    bonds.push( (iA, iB ) );
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');

    const iA = addAtom( p2(0, 0), 'a', 2 );
    const iB = addAtom( p2(0.5, 0), 'b', 3 );
    const iC = addAtom( p2(1, 0), 'c', 5 );
    const iD = addAtom( p2(3, 0.6), 'd', 4 );
    const iE = addAtom( p2(0.5, 0.6), 'e', 0 );
    const iF = addAtom( p2(0, 0.5), 'f', 6 );
    addBond( iA, iB );
    addBond( iB, iC );
    addBond( iC, iD );
    addBond( iD, iE );
    addBond( iE, iF );
    addBond( iF, iA );

    redraw();

    canvas.addEventListener( 'mousemove', onMouseMove, false );
    canvas.addEventListener( 'touchmove', onMouseMove, false );
    canvas.addEventListener( 'touchstart', onMouseDown, false );
    canvas.addEventListener( 'mousedown',  onMouseDown, false );
    canvas.addEventListener( 'touchend', onMouseUp, false );
    canvas.addEventListener( 'mouseup',  onMouseUp, false );
    canvas.addEventListener( 'mouseout',  onMouseUp, false );

    animate();
}

function redraw() {
    // clear screen
    var rect = canvas.getBoundingClientRect();
    ctx.fillStyle = 'white';
    ctx.fillRect( rect.left, rect.top, rect.width, rect.height );

    // draw bonds
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 3;
    ctx.beginPath();
    bonds.forEach( (a, b) => {
        ctx.moveTo( atoms[a].p.x * scale + offset.x, atoms[a].p.y * scale + offset.y );
        ctx.lineTo( atoms[b].p.x * scale + offset.x, atoms[b].p.y * scale + offset.y );
    });
    ctx.stroke();

    // draw atoms
    ctx.strokeStyle = 'black';
    ctx.fillStyle = 'white';
    ctx.lineWidth = 3;
    atoms.forEach( atom => drawAtom(atom) );

    // TODO: label
}

function drawAtom(atom) {
    ctx.beginPath();
    ctx.arc( atom.p.x * scale + offset.x, atom.p.y * scale + offset.x, radius * scale, 0, Math.PI * 2 );
    ctx.fill();
    ctx.stroke();
}

function animate() {
    relax();
    redraw();
    requestAnimationFrame( animate );
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

</head>

<body>

<canvas id="canvas" width="1000" height="600">(Canvas drawing not supported by your browser.)</canvas>

</html>
