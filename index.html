<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script>

function p2( x, y ) { return { x:x, y:y }; }
function add( a, b ) { return p2( a.x + b.x, a.y + b.y ); }
function sub( a, b ) { return p2( a.x - b.x, a.y - b.y ); }
function mul( a, f ) { return p2( a.x * f, a.y * f ); }
function dot( a, b ) { return a.x * b.x + a.y * b.y; }
function len2( a ) { return dot(a,a); }
function len( a ) { return Math.sqrt(len2(a)); }
function dist( a, b ) { return len( sub( a, b ) ); }
function assign( a, b ) { a.x = b.x; a.y = b.y; }
function normalize( a ) { return mul( a, 1 / len( a ) ); }
function mid( a, b ) { return mul( add( a, b ), 0.5 ); }

function atom(pos, type, state) {
    return { p: pos, type: type, state: state };
}

function reaction(a_type, a_pre, bonded_pre, b_type, b_pre, a_post, bonded_post, b_post) {
    return { a_type: a_type, a_pre: a_pre, bonded_pre: bonded_pre, b_type: b_type, b_pre: b_pre,
             a_post: a_post, bonded_post: bonded_post, b_post: b_post };
}

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function getMouseArenaPos(canvas, evt) {
    var pos = getMousePos(canvas, evt);
    return mul( sub( pos, offset ), 1.0 / scale );
}

function onMouseMove( evt ) {
    if( isDragging ) {
        var pos = getMouseArenaPos( canvas, evt );
        atoms[atomBeingDragged].p = add( pos, dragOffset );
        redraw();
    }
}

function onMouseDown( evt ) {
    var pos = getMouseArenaPos( canvas, evt );
    for(var i = 0; i < atoms.length; i++) {
        var atom = atoms[i];
        if( dist(atom.p, pos ) < radius ) {
            isDragging = true;
            dragOffset = sub( atom.p, pos );
            atomBeingDragged = i;
            break;
        }
    }
}

function onMouseUp( evt ) {
    isDragging = false;
    redraw();
}

// too close = repulsion, too far = attraction
function get_connection_force_on_a( a, b ) {
    var x = sub( a, b );
    var ab = len( x );
    var k = 0.15;
    var d = target_bond_length;
    var ret = mul( x, k * ( d - ab ) / ab );
    return ret;
}

function get_collision_force_on_a( a, b ) {
    var x = sub( a, b );
    var ab = len( x );
    var k = 0.1;
    var d = radius * 2.6;
    if( ab > d ) { return p2(0,0); } // no force if atoms aren't overlapping
    var ret = mul( x, k * ( d - ab ) / ab );
    return ret;
}

// move the verts a little in the direction of sum of the forces acting on them
function relax() {
    var forces = [];
    for(var i = 0; i < atoms.length; i++) {
        forces.push( p2(0,0) );
    }
    // add a spring force along edges
    bonds.forEach( bond => {
        const [iA, iB] = bond;
        var a = atoms[iA];
        var b = atoms[iB];
        // add the spring forces from this edge
        var m = get_connection_force_on_a( a.p, b.p );
        forces[iA] = add( forces[iA], m );
        forces[iB] = sub( forces[iB], m );
    });
    // add a collision force where atoms are overlapping
    for(var iA = 0; iA < atoms.length; iA++) {
        for(var iB = iA + 1; iB < atoms.length; iB++) {
            var a = atoms[iA];
            var b = atoms[iB];
            var m = get_collision_force_on_a( a.p, b.p );
            forces[iA] = add( forces[iA], m );
            forces[iB] = sub( forces[iB], m );
        }
    }
    // apply the movement
    var total_movement = 0;
    for(var i = 0; i < atoms.length; i++) {
        total_movement += len( forces[i] );
        atoms[i].p = add( atoms[i].p, forces[i] );
    }
    const is_relaxed = total_movement < 0.001;
    return is_relaxed;
}

function addAtom( pos, type, state ) {
    atoms.push( atom( pos, type, state ) );
    return atoms.length - 1;
}

function addBond( iA, iB ) {
    bonds.push( [iA, iB] );
}

function unbond( iA, iB ) {
    for(var i = 0; i < bonds.length; i++) {
        const bond = bonds[i];
        if( ( bond[0] == iA && bond[1] == iB ) || ( bond[1] == iA && bond[0] == iB ) ) {
            bonds.splice( i, 1 );
            return;
        }
    }
    throw 'unbond found no such bond';
}

function hasBond( iA, iB ) {
    for(var i = 0; i < bonds.length; i++) {
        const bond = bonds[i];
        if( bond[0] == iA && bond[1] == iB )
            return true;
        if( bond[1] == iA && bond[0] == iB )
            return true;
    }
    return false;
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');

    target_bond_length = 1;
    radius = target_bond_length / 3.0;
    scale = 60;
    offset = p2(200, 200);
    atoms = [];
    bonds = [];
    reactions = [
        reaction('a', 2, false, 'e', 0, 7, true, 38 ),
        reaction('c', 5, true, 'd', 4, 8, false, 9 )
    ];

    isDragging = false;

    const iA = addAtom( p2(0, 0), 'a', 2 );
    const iB = addAtom( p2(0.5, 0), 'b', 3 );
    const iC = addAtom( p2(1, 0), 'c', 5 );
    const iD = addAtom( p2(3, 0.6), 'd', 4 );
    const iE = addAtom( p2(0.5, 0.6), 'e', 0 );
    const iF = addAtom( p2(0, 0.5), 'f', 6 );
    addBond( iA, iB );
    addBond( iB, iC );
    addBond( iC, iD );
    addBond( iD, iE );
    addBond( iE, iF );
    addBond( iF, iA );

    canvas.addEventListener( 'mousemove', onMouseMove, false );
    canvas.addEventListener( 'touchmove', onMouseMove, false );
    canvas.addEventListener( 'touchstart', onMouseDown, false );
    canvas.addEventListener( 'mousedown',  onMouseDown, false );
    canvas.addEventListener( 'touchend', onMouseUp, false );
    canvas.addEventListener( 'mouseup',  onMouseUp, false );
    canvas.addEventListener( 'mouseout',  onMouseUp, false );

    redraw();
    animate();
}

function doChemistry() {
    for(var i = 0; i < reactions.length; i++) {
        const r = reactions[i];
        for(var iA = 0; iA < atoms.length; iA++) {
            for(var iB = 0; iB < atoms.length; iB++) {
                if( iA == iB ) { continue; }
                var a = atoms[iA];
                var b = atoms[iB];
                // does this reaction apply?
                if( r.a_type != a.type || r.a_pre != a.state || r.b_type != b.type || r.b_pre != b.state ) {
                    continue;
                }
                const bonded_pre = hasBond( iA, iB );
                if( r.bonded_pre && !bonded_pre ) { continue; }
                if( !r.bonded_pre && bonded_pre ) { continue; }
                // apply the reaction
                console.log('applying', r);
                a.state = r.a_post;
                b.state = r.b_post;
                if( bonded_pre && !r.bonded_post ) {
                    unbond( iA, iB );
                }
                if( !bonded_pre && r.bonded_post ) {
                    addBond( iA, iB );
                }
                return;
            }
        }
    }
}

function redraw() {
    // clear screen
    var rect = canvas.getBoundingClientRect();
    ctx.fillStyle = 'white';
    ctx.fillRect( rect.left, rect.top, rect.width, rect.height );

    // draw bonds
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 3;
    ctx.beginPath();
    bonds.forEach( bond => {
        const [a, b] = bond;
        ctx.moveTo( atoms[a].p.x * scale + offset.x, atoms[a].p.y * scale + offset.y );
        ctx.lineTo( atoms[b].p.x * scale + offset.x, atoms[b].p.y * scale + offset.y );
    });
    ctx.stroke();

    // draw atoms
    atoms.forEach( atom => drawAtom(atom) );
}

function drawAtom(atom) {
    ctx.strokeStyle = 'black';
    ctx.fillStyle = 'white';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc( atom.p.x * scale + offset.x, atom.p.y * scale + offset.x, radius * scale, 0, Math.PI * 2 );
    ctx.fill();
    ctx.stroke();

    ctx.lineWidth = 4;
    ctx.strokeStyle = 'black';
    ctx.fillStyle = 'black';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(atom.type + atom.state, atom.p.x * scale + offset.x, atom.p.y * scale + offset.x);
}

function animate() {
    const is_relaxed = relax();
    if( is_relaxed ) {
        doChemistry();
    }
    redraw();
    requestAnimationFrame( animate );
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

</head>

<body>

<canvas id="canvas" width="1000" height="600">(Canvas drawing not supported by your browser.)</canvas>

</html>
